#ifdef UNITY_MATERIAL_LIT
#include "Assets/ScriptableRenderLoop/HDRenderPipeline/Material/MaterialUtilities.hlsl"
#endif

#define UnpackNormal(x) UnpackNormalAG(x, 1.0)

void GetSurfaceAndBuiltinData(FragInputs fragInput, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData)
{
    ZERO_INITIALIZE(SurfaceData, surfaceData);
    ZERO_INITIALIZE(BuiltinData, builtinData);
${PixelShaderInitialize}
${PixelShaderBody}

    /* this clip could be integrated earlier for optimisation */
#ifdef _ALPHATEST_ON
    clip(builtinData.opacity - _AlphaCutoff);
#endif

#ifdef UNITY_MATERIAL_LIT
    /* HotFix to keep the PreIntegratedFGD shared texture sampler (TODO : workaround until we support independant sampler declaration)*/
    surfaceData.specularOcclusion = max(surfaceData.specularOcclusion, 10e-5f);
#endif
}

#if 1 //lazy implementation : use define approach
${TemporaryAdditionnalDefines}
	#include "Assets/ScriptableRenderLoop/HDRenderPipeline/ShaderPass/VaryingMesh.hlsl"
	
#else
//WIP : old implementation (needs refactor to use this approach, should be better packing)
struct Attributes
{
    float3 positionOS : POSITION;
${VertexAttributes}
};

struct Varyings
{
    float4 positionCS;
${VaryingAttributes}
};

struct PackedVaryingsToPS
{
    float4 positionCS : SV_Position;
${PackedVaryingAttributes}
};

PackedVaryingsToPS PackVaryings(Varyings input)
{
    PackedVaryingsToPS output;
    output.positionCS = input.positionCS;
${PackingVaryingCode}
    return output;
}

FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsToPS input)
{
    FragInputs output;
    ZERO_INITIALIZE(FragInputs, output);

    output.unPositionSS = input.positionCS;
${UnpackVaryingCode}
    return output;
}

PackedVaryingsToPS VertDefault(Attributes input)
{
    Varyings output;

#if SHADERPASS == SHADERPASS_LIGHT_TRANSPORT
    // Output UV coordinate in vertex shader
    if (unity_MetaVertexControl.x)
    {
        input.positionOS.xy = input.texCoord1 * unity_LightmapST.xy + unity_LightmapST.zw;
        // OpenGL right now needs to actually use incoming vertex position,
        // so use it in a very dummy way
        //v.positionOS.z = vertex.z > 0 ? 1.0e-4f : 0.0f;
    }
    if (unity_MetaVertexControl.y)
    {
        input.positionOS.xy = input.texCoord2 * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
        // OpenGL right now needs to actually use incoming vertex position,
        // so use it in a very dummy way
        //v.positionOS.z = vertex.z > 0 ? 1.0e-4f : 0.0f;
    }
#endif

    output.positionCS = TransformWorldToHClip(TransformObjectToWorld(input.positionOS));
${VertexShaderBody}
    return PackVaryings(output);
}
#endif